<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8" />
    <title>Schach mit Promotion-Auswahl</title>
    <style>
        #board {
            display: grid;
            grid-template-columns: repeat(8, 50px);
            width: 400px;
        }

        .square {
            width: 50px;
            height: 50px;
            line-height: 50px;
            text-align: center;
            font-size: 32px;
            cursor: pointer;
        }

        .white {
            background-color: #f0d9b5;
        }

        .black {
            background-color: #b58863;
        }

        .selected {
            outline: 3px solid red;
        }

        #status {
            margin-top: 10px;
        }

        button {
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div id="board"></div>
    <div id="status"></div>
    <button id="resetBtn">Neues Spiel</button>

    <script>
        const boardEl = document.getElementById('board');
        const statusEl = document.getElementById('status');
        const resetBtn = document.getElementById('resetBtn');

        // Unicode Figuren (Groß = Weiß, Klein = Schwarz)
        const piecesUnicode = {
            'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
            'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
        };

        // Startstellung FEN
        const startFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR";

        let board = [];
        let isWhiteTurn = true;
        let selectedSquare = null;
        let castlingRights = {
            whiteKingMoved: false,
            whiteRookLeftMoved: false,
            whiteRookRightMoved: false,
            blackKingMoved: false,
            blackRookLeftMoved: false,
            blackRookRightMoved: false
        };

        function fenToBoard(fen) {
            const rows = fen.split("/");
            const b = [];
            for (let r = 0; r < 8; r++) {
                const row = [];
                for (let c = 0; c < rows[r].length; c++) {
                    const ch = rows[r][c];
                    if (isNaN(ch)) {
                        row.push(ch);
                    } else {
                        for (let i = 0; i < Number(ch); i++) row.push(null);
                    }
                }
                b.push(row);
            }
            return b;
        }

        function boardToFen(board) {
            let fen = "";
            for (let r = 0; r < 8; r++) {
                let emptyCount = 0;
                for (let c = 0; c < 8; c++) {
                    if (!board[r][c]) {
                        emptyCount++;
                    } else {
                        if (emptyCount > 0) {
                            fen += emptyCount;
                            emptyCount = 0;
                        }
                        fen += board[r][c];
                    }
                }
                if (emptyCount > 0) fen += emptyCount;
                if (r < 7) fen += "/";
            }
            return fen;
        }

        function drawBoard() {
            boardEl.innerHTML = "";
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const sq = document.createElement("div");
                    sq.className = "square " + (((r + c) % 2 === 0) ? "white" : "black");
                    sq.dataset.row = r;
                    sq.dataset.col = c;
                    if (board[r][c]) sq.textContent = piecesUnicode[board[r][c]];
                    if (selectedSquare && selectedSquare[0] === r && selectedSquare[1] === c) {
                        sq.classList.add("selected");
                    }
                    sq.addEventListener("click", onSquareClick);
                    boardEl.appendChild(sq);
                }
            }
        }

        function isOwnPiece(piece) {
            if (!piece) return false;
            return (isWhiteTurn) ? (piece === piece.toUpperCase()) : (piece === piece.toLowerCase());
        }

        function isInCheck(board, white) {
            // Vereinfachte Check-Erkennung (für Demo)
            // Find König
            let kingPos = null;
            const kingChar = white ? 'K' : 'k';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c] === kingChar) {
                        kingPos = [r, c];
                        break;
                    }
                }
                if (kingPos) break;
            }
            if (!kingPos) return false; // König nicht gefunden?

            // Prüfe alle gegnerischen Figuren, ob sie den König angreifen können
            // Für Demo nur Grundzüge (für detaillierte Regeln müsste man alle Zugarten implementieren)
            const enemyPieces = (white) ? 'prnbqk' : 'PRNBQK';
            // (Hier Beispiel-Check, echte Logik wäre umfangreicher)
            // Wir skippen die volle Implementierung aus Platzgründen, angenommen nie Schach.

            return false;
        }

        function hasAnyValidMove(white) {
            // Placeholder: Einfach true zurückgeben (für Demo)
            return true;
        }

        // Funktion zum Prüfen ob Pfad frei ist zwischen from und to (für Läufer, Turm, Dame)
        function isClearPath(fromRow, fromCol, toRow, toCol) {
            let dr = Math.sign(toRow - fromRow);
            let dc = Math.sign(toCol - fromCol);
            let r = fromRow + dr;
            let c = fromCol + dc;
            while (r !== toRow || c !== toCol) {
                if (board[r][c]) return false;
                r += dr;
                c += dc;
            }
            return true;
        }

        async function tryMove(from, to) {
            let [fr, fc] = from;
            let [tr, tc] = to;
            const piece = board[fr][fc];
            if (!piece) return false;
            if (!isOwnPiece(piece)) return false;
            const isWhite = piece === piece.toUpperCase();

            const dr = tr - fr;
            const dc = tc - fc;
            const absDr = Math.abs(dr);
            const absDc = Math.abs(dc);

            // Hilfsfunktion: Eigene Figuren blockieren Züge
            if (board[tr][tc] && isOwnPiece(board[tr][tc])) return false;

            // Kopie für Rückgängig
            const oldBoard = board.map(r => r.slice());
            const oldCastling = { ...castlingRights };

            // Bewegung validieren & ausführen
            async function doMove() {
                switch (piece.toLowerCase()) {
                    case 'k':
                        if (absDr <= 1 && absDc <= 1) {
                            board[tr][tc] = piece;
                            board[fr][fc] = null;
                            // Rochade Rechte setzen
                            if (isWhite) castlingRights.whiteKingMoved = true;
                            else castlingRights.blackKingMoved = true;
                            return true;
                        }
                        // Rochade kurz
                        if (dc === 2 && dr === 0) {
                            if (isWhite && canCastleShort(true)) {
                                // König bewegt sich 2 Felder nach rechts
                                board[7][4] = null;
                                board[7][6] = 'K';
                                board[7][7] = null;
                                board[7][5] = 'R';
                                castlingRights.whiteKingMoved = true;
                                castlingRights.whiteRookRightMoved = true;
                                return true;
                            }
                            if (!isWhite && canCastleShort(false)) {
                                board[0][4] = null;
                                board[0][6] = 'k';
                                board[0][7] = null;
                                board[0][5] = 'r';
                                castlingRights.blackKingMoved = true;
                                castlingRights.blackRookRightMoved = true;
                                return true;
                            }
                            return false;
                        }
                        // Rochade lang
                        if (dc === -2 && dr === 0) {
                            if (isWhite && canCastleLong(true)) {
                                board[7][4] = null;
                                board[7][2] = 'K';
                                board[7][0] = null;
                                board[7][3] = 'R';
                                castlingRights.whiteKingMoved = true;
                                castlingRights.whiteRookLeftMoved = true;
                                return true;
                            }
                            if (!isWhite && canCastleLong(false)) {
                                board[0][4] = null;
                                board[0][2] = 'k';
                                board[0][0] = null;
                                board[0][3] = 'r';
                                castlingRights.blackKingMoved = true;
                                castlingRights.blackRookLeftMoved = true;
                                return true;
                            }
                            return false;
                        }
                        return false;

                    case 'q':
                        if ((dr === 0 || dc === 0 || absDr === absDc) && isClearPath(fr, fc, tr, tc)) {
                            board[tr][tc] = piece;
                            board[fr][fc] = null;
                            return true;
                        }
                        return false;

                    case 'r':
                        if ((dr === 0 || dc === 0) && isClearPath(fr, fc, tr, tc)) {
                            board[tr][tc] = piece;
                            board[fr][fc] = null;
                            // Turm gezogen -> Rechte sperren
                            if (isWhite) {
                                if (fr === 7 && fc === 0) castlingRights.whiteRookLeftMoved = true;
                                if (fr === 7 && fc === 7) castlingRights.whiteRookRightMoved = true;
                            } else {
                                if (fr === 0 && fc === 0) castlingRights.blackRookLeftMoved = true;
                                if (fr === 0 && fc === 7) castlingRights.blackRookRightMoved = true;
                            }
                            return true;
                        }
                        return false;

                    case 'b':
                        if (absDr === absDc && isClearPath(fr, fc, tr, tc)) {
                            board[tr][tc] = piece;
                            board[fr][fc] = null;
                            return true;
                        }
                        return false;

                    case 'n':
                        if ((absDr === 2 && absDc === 1) || (absDr === 1 && absDc === 2)) {
                            board[tr][tc] = piece;
                            board[fr][fc] = null;
                            return true;
                        }
                        return false;

                    case 'p':
                        const dir = isWhite ? -1 : 1;
                        // Einfacher Zug
                        if (dc === 0 && dr === dir && !board[tr][tc]) {
                            board[tr][tc] = piece;
                            board[fr][fc] = null;
                        }
                        // Erster Zug 2 Felder
                        else if (dc === 0 && dr === 2 * dir && !board[tr][tc] && !board[fr + dir][fc]) {
                            board[tr][tc] = piece;
                            board[fr][fc] = null;
                        }
                        // Schlagzug
                        else if (Math.abs(dc) === 1 && dr === dir && board[tr][tc] && !isOwnPiece(board[tr][tc])) {
                            board[tr][tc] = piece;
                            board[fr][fc] = null;
                        }
                        else return false;

                        // Prüfen auf Promotion
                        const lastRow = isWhite ? 0 : 7;
                        if (tr === lastRow) {
                            // Zeige Promotion Auswahl
                            return new Promise(resolve => {
                                const promotionDiv = document.createElement('div');
                                promotionDiv.style.position = 'fixed';
                                promotionDiv.style.top = '50%';
                                promotionDiv.style.left = '50%';
                                promotionDiv.style.transform = 'translate(-50%, -50%)';
                                promotionDiv.style.backgroundColor = 'white';
                                promotionDiv.style.border = '2px solid black';
                                promotionDiv.style.padding = '20px';
                                promotionDiv.style.zIndex = 1000;
                                promotionDiv.textContent = 'Wähle eine Figur zur Umwandlung: ';

                                ['q', 'r', 'b', 'n'].forEach(promo => {
                                    const btn = document.createElement('button');
                                    btn.textContent = promo.toUpperCase();
                                    btn.style.margin = '5px';
                                    btn.onclick = () => {
                                        const promoPiece = isWhite ? promo.toUpperCase() : promo;
                                        board[tr][tc] = promoPiece;
                                        document.body.removeChild(promotionDiv);
                                        resolve(true);
                                    };
                                    promotionDiv.appendChild(btn);
                                });

                                document.body.appendChild(promotionDiv);
                            });
                        }

                        return true;
                }
                return false;
            }

            if (!(await doMove())) return false;

            // Prüfe Schach nach Zug, Zug ggf. rückgängig machen
            if (isInCheck(board, isWhite)) {
                board = oldBoard;
                castlingRights = oldCastling;
                return false;
            }

            return true;
        }

        function canCastleShort(isWhite) {
            if (isWhite) {
                if (castlingRights.whiteKingMoved || castlingRights.whiteRookRightMoved) return false;
                if (board[7][5] || board[7][6]) return false;
                if (isInCheck(board, true)) return false;
                let tempBoard = board.map(r => r.slice());
                tempBoard[7][4] = null; tempBoard[7][5] = 'K';
                if (isInCheck(tempBoard, true)) return false;
                tempBoard[7][5] = null; tempBoard[7][6] = 'K';
                if (isInCheck(tempBoard, true)) return false;
                return true;
            } else {
                if (castlingRights.blackKingMoved || castlingRights.blackRookRightMoved) return false;
                if (board[0][5] || board[0][6]) return false;
                if (isInCheck(board, false)) return false;
                let tempBoard = board.map(r => r.slice());
                tempBoard[0][4] = null; tempBoard[0][5] = 'k';
                if (isInCheck(tempBoard, false)) return false;
                tempBoard[0][5] = null; tempBoard[0][6] = 'k';
                if (isInCheck(tempBoard, false)) return false;
                return true;
            }
        }
        function canCastleLong(isWhite) {
            if (isWhite) {
                if (castlingRights.whiteKingMoved || castlingRights.whiteRookLeftMoved) return false;
                if (board[7][1] || board[7][2] || board[7][3]) return false;
                if (isInCheck(board, true)) return false;
                let tempBoard = board.map(r => r.slice());
                tempBoard[7][4] = null; tempBoard[7][3] = 'K';
                if (isInCheck(tempBoard, true)) return false;
                tempBoard[7][3] = null; tempBoard[7][2] = 'K';
                if (isInCheck(tempBoard, true)) return false;
                return true;
            } else {
                if (castlingRights.blackKingMoved || castlingRights.blackRookLeftMoved) return false;
                if (board[0][1] || board[0][2] || board[0][3]) return false;
                if (isInCheck(board, false)) return false;
                let tempBoard = board.map(r => r.slice());
                tempBoard[0][4] = null; tempBoard[0][3] = 'k';
                if (isInCheck(tempBoard, false)) return false;
                tempBoard[0][3] = null; tempBoard[0][2] = 'k';
                if (isInCheck(tempBoard, false)) return false;
                return true;
            }
        }

        async function onSquareClick(event) {
            if (!selectedSquare) {
                const r = parseInt(event.currentTarget.dataset.row);
                const c = parseInt(event.currentTarget.dataset.col);
                const piece = board[r][c];
                if (!piece) return;
                if (!isOwnPiece(piece)) return;
                selectedSquare = [r, c];
                drawBoard();
            } else {
                const r = parseInt(event.currentTarget.dataset.row);
                const c = parseInt(event.currentTarget.dataset.col);
                if (await tryMove(selectedSquare, [r, c])) {
                    isWhiteTurn = !isWhiteTurn;
                    selectedSquare = null;
                    updateStatus();
                    drawBoard();
                } else {
                    alert("Ungültiger Zug!");
                    selectedSquare = null;
                    drawBoard();
                }
            }
        }

        function updateStatus() {
            if (isInCheck(board, isWhiteTurn)) {
                if (!hasAnyValidMove(isWhiteTurn)) {
                    statusEl.textContent = `Schachmatt! ${(isWhiteTurn ? "Schwarz" : "Weiß")} gewinnt!`;
                    boardEl.style.pointerEvents = "none";
                    return;
                }
                statusEl.textContent = (isWhiteTurn ? "Weiß" : "Schwarz") + " ist im Schach.";
            } else {
                if (!hasAnyValidMove(isWhiteTurn)) {
                    statusEl.textContent = "Patt! Unentschieden.";
                    boardEl.style.pointerEvents = "none";
                    return;
                }
                statusEl.textContent = (isWhiteTurn ? "Weiß" : "Schwarz") + " ist am Zug.";
            }
            boardEl.style.pointerEvents = "auto";
        }

        function initGame() {
            board = fenToBoard(startFEN);
            isWhiteTurn = true;
            selectedSquare = null;
            castlingRights = {
                whiteKingMoved: false,
                whiteRookLeftMoved: false,
                whiteRookRightMoved: false,
                blackKingMoved: false,
                blackRookLeftMoved: false,
                blackRookRightMoved: false
            };
            drawBoard();
            updateStatus();
        }

        resetBtn.onclick = () => {
            initGame();
        };

        initGame();
    </script>
</body>
</html>
